# Лабораторная работа №2: Среда исполнения программ на языке Pascal--

---

## Техническое задание

### 1. Цель проекта

Разработка интегрированной среды разработки и исполнения программ на языке **Pascal--**, поддерживающей:

- написание и анализ кода;
- синтаксическую проверку;
- выполнение программ с пользовательским вводом и базовой логикой.

### 2. Функциональные требования

#### 2.1. Работа с текстом программы

- Представление текста в виде иерархического списка (приближённо — абстрактное синтаксическое дерево).
- Поддержка базовых конструкций Pascal--:
  - `const`, `var`, `begin` ... `end`, `if ... then ... else`, `Read`, `Write`.
  - Арифметические и логические выражения.
  - Вложенные блоки и условные операторы.

#### 2.2. Таблица идентификаторов

Хранение переменных и констант в одной из структур (на выбор):

- упорядоченная таблица;
- дерево поиска;
- хеш-таблица.

Каждая запись должна содержать:

- имя;
- тип (`integer`, `double`);
- значение.

#### 2.3. Вычисления и исполнение

- Выражения (арифметические и условные) преобразуются в постфиксную форму (Reverse Polish Notation).
- Исполнение производится с использованием стека.

Поддерживаемые операторы:

- Арифметические: `+`, `-`, `*`, `/`, `div`, `mod`.
- Логические: `=`, `<>`, `<`, `>`, `<=`, `>=`.

Исполняемые действия:

- Построчное выполнение с учётом вложенных блоков;
- `Read` — пользовательский ввод;
- `Write` — вывод значений.

#### 2.4. Синтаксический анализ

- Сборка синтаксического дерева.
- Проверка структуры программы:
  - отсутствие `begin/end`;
  - несоответствие типов;
  - недопустимые символы или конструкции;
  - неверные имена переменных и констант.

#### 2.5. Интерфейс пользователя

- Консольный (редактирование необязательно) или графический интерфейс (по желанию).
- Возможности:
  - загрузка и отображение программ;
  - запуск и вывод результатов;
  - отображение ошибок.

### 3. Пример работы

Пример исходной программы:

```pascal
const a = 5;
var x, y;
begin
  Read(x);
  y := a * x + 3;
  if y > 10 then
    Write(y)
  else
    Write(a)
end.
```
Ввод: x = 2  
Результат: Write -> 13  
(так как y = 5 * 2 + 3 = 13 > 10, выводится 13)

Ввод: x = 1  
Результат: Write -> 5  
(так как y = 8, выполняется else, выводится a = 5)

### 4. Нефункциональные требования

- Язык реализации: **C++**.
- Поддержка сборки в **Visual Studio**.
- Подключение **Google Test** для модульного тестирования.
- Структура проекта:
  - `Parser/` — синтаксический анализ;
  - `Executor/` — выполнение программ;
  - `SymbolTable/` — таблица идентификаторов;
  - `RPN/` — постфиксная форма и стек.

### 5. Распределение работ

| Участник           | Задачи                                                                 |
|--------------------|------------------------------------------------------------------------|
| Долов Вячеслав     | Таблица идентификаторов, структура программы |
| Константинов Семён  | Интерпретатор, пользовательский интерфейс         |
| Кутергин Валентин  | Постфиксный калькулятор, синтаксический разбор          |


### 6. План разработки

| Неделя | Задачи                                                                        |
|--------|--------------------------------------------------------------------------------|
| 1      | Подготовка технического задания, создание репозитория                         |
| 2      | Анализ предметной области, список объектов и алгоритмов                       |
| 3      | Проектирование классов, структура программы                                   |
| 4      | Заготовки классов, пустые юнит-тесты                                          |
| 5–7    | Реализация компонентов, тестирование, интеграция                              |
| 8      | Финальная проверка, документация, сдача проекта                               |

### 7. Требования к тестированию

Тестирование должно включать:

- Проверку всех операций с идентификаторами:
  - Добавление, поиск, извлечение;
  - Поведение при дублирующихся именах;
- Корректность вычислений:
  - Арифметические и логические выражения;
  - Преобразование в постфиксную форму;
  - Вычисление выражений, включая вложенные;
- Проверку интерпретации:
  - Выполнение вложенных блоков;
  - Обработка `Read` и `Write`;
- Обнаружение ошибок:
  - Деление на ноль;
  - Неинициализированные переменные;
  - Ошибки синтаксиса (`:=`, `;`, `begin/end`);
  - Недопустимые идентификаторы и символы.

### 8. Сдача проекта

- **Исходный код** — в репозитории **GitHub**.
- **Документация** (файл `README.md`) — с инструкцией по сборке и запуску.
- **Примеры программ** — для демонстрации возможностей.
- **Отчёт о тестировании** — с описанием покрытых случаев.

---

## Список объектов и основных алгоритмов


---

### 1. Класс `Lexer`

**Методы:**
- `vector<Lexeme> Tokenize(const string& sourceCode)` — преобразует исходный код в список лексем.

**Структуры:**
- `Lexeme` — содержит тип лексемы (`LexemeType`) и её строковое значение.

---

### 2. Структура `HLNode`

**Методы:**
- `void addNext(HLNode* child)` — добавляет следующий узел на том же уровне.
- `void addChild(HLNode* child)` — добавляет дочерний узел ниже по уровню.

**Поля:**
- `HLNode* pnext` — указатель на следующий узел.
- `HLNode* pdown` — указатель на дочерний узел.
- `Lexeme* lex` — указатель на лексему.

---

### 3. Класс `Parser`

**Методы:**
- `void CheckForErrors(vector<Lexeme>& lexemes)` — проверяет токенизированный текст программы на ошибки.
- `HLNode* BuildHList(vector<Lexeme>& lexemes)` — строит иерархический список из вектора лексем.

---

### 4. Класс `PostfixExecutor`

**Методы:**
- `PostfixExecutor(TableManager* varTablep)` — конструктор.
- `void toPostfix(HLNode start)` — преобразует иерархический список в постфиксную форму.
- `bool executePostfix()` — выполняет постфиксное выражение.

**Поля:**
- `TableManager* vartable` — таблица переменных.
- `vector<Lexeme> postfix` — постфиксное представление выражения.

---

### 5. Класс `ProgramExecutor`

**Методы:**
- `void Execute(HLNode* head)` — выполняет программу, представленную иерархическим списком.

**Поля:**
- `TableManager vartable` — таблица переменных.
- `PostfixExecutor postfix` — исполнитель постфиксных выражений.

---

### 6. Класс `TableManager`

**Методы:**
- `void addInt(int val)` — добавляет целочисленное значение.
- `void addDouble(double val)` — добавляет значение с плавающей точкой.
- `void addString(double val)` — добавляет строковое значение.
- `int& getInt(string name)` — возвращает целочисленную переменную.
- `double& getDouble(string name)` — возвращает переменную с плавающей точкой.
- `string& getString(string name)` — возвращает строковую переменную.

**Поля:**
- `THashTableChain<string, int> inttable` — таблица целочисленных переменных.
- `THashTableChain<string, double> doubletable` — таблица переменных с плавающей точкой.
- `THashTableChain<string, string> strtable` — таблица строковых переменных.

---

### 7. Класс `THashTableChain`

**Методы:**
- `size_t HashFunction(const TKey& key) const` — хеш-функция.
- `void Insert(const TKey& key, const TValue& value)` — вставляет пару ключ-значение.
- `void Delete(const TKey& key)` — удаляет значение по ключу.
- `TValue* Find(const TKey& key)` — находит значение по ключу.
- `void Print() const` — выводит содержимое таблицы.
- `TValue& operator[](const TKey& key)` — доступ к значению по ключу.

**Поля:**
- `vector<list<Node>> data` — данные таблицы.
- `size_t bucketCount` — количество корзин.
